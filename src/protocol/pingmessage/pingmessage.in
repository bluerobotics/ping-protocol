#pragma once

/// {name} objects provide a wrapper over vector
/// for convenient access and packing of field data
///
/// These files are generated by the ping_generator.py
/// script found in this directory
class {name} // TODO inherit vector?
{{
public:
    {name}() {{}}
    {name}(QByteArray& buf) {{ msgData = std::vector<uint8_t>(buf.begin(), buf.end()); }}
    {name}(std::vector<uint8_t>& buf) {{ msgData = buf; }}
    {name}({name}& msg) {{ msgData = msg.msgData; }}
    ~{name}() {{}}
    {enums}
    std::vector<uint8_t> msgData;

    uint16_t   payload_length()    {{ return *(uint16_t*)(msgData.data() + 2); }} // This is ok only because alignment is static
    uint16_t   message_id()        {{ return *(uint16_t*)(msgData.data() + 4); }} // This is ok only because alignment is static
    uint8_t    src_device_id()     {{ return *(msgData.data() + 6); }}
    uint8_t    dst_device_id()     {{ return *(msgData.data() + 7); }}
    uint16_t   checksum()          {{ uint16_t d; memcpy(&d, (msgData.data() + msgData.size() - 2), 2); return d; }} // This is required because alignment may be incorrect

    bool verifyChecksum() {{
        return checksum() == calculateChecksum();;
    }}

    void updateChecksum() {{
        uint16_t cs = calculateChecksum();
        memcpy(msgData.data() + msgData.size() - 2, &cs, 2);
    }}

    uint16_t calculateChecksum() {{
        uint16_t checksum = 0;
        for(uint32_t i = 0; i < msgData.size()-2 /*checksumbytes*/; i++) {{
            checksum += msgData.at(i);
        }}
        return checksum;
    }}
}};
