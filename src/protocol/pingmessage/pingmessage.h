#pragma once

/// PingMessage objects provide a wrapper over vector
/// for convenient access and packing of field data
///
/// These files are generated by the ping_generator.py
/// script found in this directory
class PingMessage // TODO inherit vector?
{
public:
    PingMessage() {}
    PingMessage(QByteArray& buf) { msgData = std::vector<uint8_t>(buf.begin(), buf.end()); }
    PingMessage(std::vector<uint8_t>& buf) { msgData = buf; }
    PingMessage(PingMessage& msg) { msgData = msg.msgData; }
    ~PingMessage() {}

    enum GeneralMessageID {
         gen_goto_bootloader = 100
        ,gen_get_version = 101
        ,gen_device_id = 110
        ,gen_new_data = 112
        ,gen_cmd_request = 120
    };

    enum SonarMessageID {
         sonar_set_velocity = 1000
    };

    enum EchosounderMessageID {
         es_distance_simple = 1100
        ,es_distance = 1101
        ,es_profile
        ,es_range = 1110
        ,es_mode
        ,es_rate
        ,es_gain
        ,es_pulse
    };

    enum MechanicalScanningSonarMessageID {
         mss_angle_profile = 1201
        ,mss_range = 1210
        ,mss_mode
        ,mss_gain
        ,mss_sector
    };

    std::vector<uint8_t> msgData;

    uint16_t   payload_length()    { return *(uint16_t*)(msgData.data() + 2); } // This is ok only because alignment is static
    uint16_t   message_id()        { return *(uint16_t*)(msgData.data() + 4); } // This is ok only because alignment is static
    uint8_t    src_device_id()     { return *(msgData.data() + 6); }
    uint8_t    dst_device_id()     { return *(msgData.data() + 7); }
    uint16_t   checksum()          { uint16_t d; memcpy(&d, (msgData.data() + msgData.size() - 2), 2); return d; } // This is required because alignment may be incorrect

    bool verifyChecksum() {
        return checksum() == calculateChecksum();;
    }

    void updateChecksum() {
        uint16_t cs = calculateChecksum();
        memcpy(msgData.data() + msgData.size() - 2, &cs, 2);
    }

    uint16_t calculateChecksum() {
        uint16_t checksum = 0;
        for(uint32_t i = 0; i < msgData.size()-2 /*checksumbytes*/; i++) {
            checksum += msgData.at(i);
        }
        return checksum;
    }
};
