#!/usr/bin/python -u

# Ping1D.py
# A device API for the Blue Robotics Ping1D echosounder

#~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
#~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from Ping import PingMessage
import serial
import time

class Ping1D(object):
    def __init__(self, deviceName, baudrate=115200):
        if deviceName is None:
            print("Device name is required")
            return

        try:
            print("Opening %s at %d bps" % (deviceName, baudrate))

            ## Serial object for device communication
            self.iodev = serial.Serial(deviceName, baudrate)
            self.iodev.timeout = 1

        except Exception as e:
            print("Failed to open the given serial port")
            print("\t", e)
            exit(1)

        ## A helper class to take care of decoding the input stream
        self.parser = PingMessage.PingParser()

        ## device id of this Ping1D object, used for dst_device_id in outgoing messages
        self.my_id = 255

    ## Consume rx buffer data until a new message is successfully decoded
    # @return A new PingMessage: as soon as a message is parsed (there may be data remaining in the buffer to be parsed, thus requiring subsequent calls to read())
    # @return None: if the buffer is empty and no message has been parsed
    def read(self):
        while(self.iodev.in_waiting):
            b = self.iodev.read()

            if self.parser.parseByte(ord(b)) == PingMessage.PingParser.NEW_MESSAGE:
                self.handleMessage(self.parser.rxMsg)
                return self.parser.rxMsg
        return None

    ## Write data to device
    def write(self, data):
        return self.iodev.write(data)

    ## Make sure there is a device on the line and read some initial data
    # Return True if the device replies with expected data
    # Return False otherwise
    def initialize(self):
        if self.request(PingMessage.PING1D_VOLTAGE_5) is None:
            return False
        return True

    ## Request the given message ID
    # Return response if it is rxed within timeout period, None otherwise
    # TODO handle nack to exit without blocking
    def request(self, m_id, timeout=0.35):
        msg = PingMessage.PingMessage()
        msg.request_id = m_id
        msg.packMsgData()
        self.write(msg.msgData)
        return self.waitReply(m_id, timeout)

    ## Wait for the device to send a message with the desired message_id for timeout s
    # Return True if a valid message is received from the device with the desired message_id before the timeout period expires
    # Return False otherwise
    def waitReply(self, message_id, timeout=0.5):
        tstart = time.time()
        while(time.time() < tstart + timeout):
            msg = self.read()
            if msg is not None:
                if msg.message_id == message_id:
                    return msg
        return None

    ## Handle an incoming messge from the device
    # Extract message fields into self attributes
    def handleMessage(self, msg):
        if msg.message_id in PingMessage.payloadDict:
            for attr in PingMessage.payloadDict[msg.message_id]["field_names"]:
                setattr(self, attr, getattr(msg, attr))
        else:
            print("Unrecognized message: %d", msg)

    ## Dump object into string representation
    def __repr__(self):
        representation = "---------------------------------------------------------\n~Ping1D Object~"

        attrs = vars(self)
        for attr in sorted(attrs):
            try:
                if attr != 'iodev':
                    representation += "\n  - " + attr + "(hex): " + str([hex(ord(item)) for item in getattr(self, attr)])
                if attr != 'data':
                    representation += "\n  - " + attr + "(string): " + str(getattr(self, attr))
            except:
                representation += "\n  - " + attr + ": " + str(getattr(self, attr))
        return representation

    # Access Methods
    ################
    # Request a message from the device
    # If there is no reply return None, otherwise return a dictionary of the updated values

{% for msg in messages["ping1D"]["get"] %}
    ## {{messages["ping1D"]["get"][msg].description}}
    #  Returns a dictionary of the reply payload
{% for field in messages["ping1D"]["get"][msg].payload %}
    #  @return {{field.name}}: {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor%}
    def get_{{msg}}(self):
        if self.request(PingMessage.PING1D_{{msg|upper}}) is None:
            return None
        data = ({
{% for field in messages["ping1D"]["get"][msg].payload %}
            "{{field.name}}": self.{{field.name}}, # {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
        })
        return data

{% endfor %}
    # Control Methods
    ###################
    # Write a new control, and read the values back from the device
    # If verify is true, fail if the values read back from the device do not match the controls that were written
    # Return True on success
    # Return False on failure to read values back or on verification failure

{% for msg in messages["ping1D"]["set"] %}
    ## {{messages["ping1D"]["set"][msg].description}}
{% for field in messages["ping1D"]["set"][msg].payload %}
    #  @param {{field.name}} - {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
    def {{msg}}(self{% for field in messages["ping1D"]["set"][msg].payload %}, {{field.name}}{% endfor %}, verify=True):
        m = PingMessage.PingMessage(PingMessage.PING1D_{{msg|upper}})
{% for field in messages["ping1D"]["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.packMsgData()
        self.write(m.msgData)
        if self.request(PingMessage.PING1D_{{msg|replace("set_", "")|upper}}) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
{% if messages["ping1D"]["set"][msg].payload %}
              and {% for field in messages["ping1D"]["set"][msg].payload %}self.{{field.name}} != {{field.name}}
              or {% endfor %}False):
{% endif %}
            return False
        return True # success

{% endfor %}

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=True, type=str, help="Ping device port.")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate.")
    args = parser.parse_args()

    p = Ping1D(args.device, args.baudrate)

    print("Initialized: %s" % p.initialize())

{% for msg in messages["ping1D"]["get"] %}
    print("\ntesting get_{{msg}}")
    result = p.get_{{msg}}()
    print("  " + str(result))
    print("  > > pass: %s < <" % (result != None))

{% endfor %}
    print("\ntesting set_device_id")
    print("  > > pass: %s < <" % p.set_device_id(43))
    print("\ntesting set_range")
    print("  > > pass: %s < <" % p.set_range(1000, 2000))
    print("\ntesting set_speed_of_sound")
    print("  > > pass: %s < <" % p.set_speed_of_sound(1444000))
    print("\ntesting set_mode_auto")
    print("  > > pass: %s < <" % p.set_mode_auto(False))
    print("\ntesting set_ping_rate")
    print("  > > pass: %s < <" % p.set_ping_rate(36))
    print("\ntesting set_gain_index")
    print("  > > pass: %s < <" % p.set_gain_index(3))

    # Not implemented
    # print("testing set_ping_enable")
    # print("  > > pass: %s < <" % p.set_ping_enable(0))

    print(p)

