/*
* ping1d.h
* A device API for the Blue Robotics Ping1D echosounder
*
*~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
* THIS IS AN AUTOGENERATED FILE
* DO NOT EDIT
*~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
*
*/

#pragma once

#include <Arduino.h>
#include <Stream.h>
#include "pingmessage.h"
#include "ping_parser.h"

class Ping1D
{
public:

    /**
     *  @brief Constructor
     *
     *  @param ser: The device I/O
     */
    Ping1D(Stream& ser);

    /**
     * @brief Destructor
     */
    ~Ping1D();

    /**
     *  @brief Establish communications with the device, and initialize the update interval
     *
     *  @param ping_interval_ms: The interval (in milliseconds) between acoustic measurements
     *
     *  @return true if the device was initialized successfully
     */
    bool initialize(uint16_t ping_interval_ms = 50);

    /**
     *  @brief Request a PingMessage from the device
     *
     *  @param id: The message ID to request
     *  @param timeout_ms: The timeout period to wait for the requested PingMessage to be received
     *
     *  @return The PingMessage that was requested
     *  @return null if the device did not reply with the requested message before the timeout period expired
     *
     *  @par ex.
     *  @code
     *  ping_msg_ping1D_voltage_5 msg(*pd.request(Ping1DNamespace::Voltage_5));
     *  @endcode
     */
    PingMessage* request(enum Ping1DNamespace::msg_ping1D_id id, uint16_t timeout_ms = 500);


    /**
     *  @brief Request a PingMessage of type T from the device
     *
     *  @param timeout_ms: The timeout period to wait for the requested PingMessage to be received
     *
     *  @return The PingMessage that was requested
     *  @return null if the device did not reply with the requested message before the timeout period expired
     *
     *  @par ex.
     *  @code
     *  auto msg = pd.request<ping_msg_ping1D_voltage_5>();
     *  @endcode
     */
    template <typename T>
    T* request();

    /**
     *  @brief Helper to request distance and confidence
     *
     *  @return true if the distance and confidence have been updated successfully
     */
    bool update() {
        return request(Ping1DNamespace::Distance_simple);
    }

{% for msg in messages["ping1D"]["set"] %}
    /**
     * @brief {{messages["ping1D"]["set"][msg].description}}
     *
{% for field in messages["ping1D"]["set"][msg].payload %}
     * @param {{field.name}} - {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
     *
     * @return true when verify = false if a valid reply is received from the device.
     * @return true when verify = true if a valid reply is received from the
     * device, and the values in the reply match the values that we applied
     */
    bool {{msg}}({% for field in messages["ping1D"]["set"][msg].payload %}{{get_type_string(field.type)}} {{field.name}}, {% endfor %}bool verify = true);

{% endfor %}

{% for field in proplist %}
    // Return the latest value received
{% if is_vector(proplist[field].type) %}
{% if proplist[field].vector.sizetype %}
    {{get_type_string(proplist[field].vector.sizetype)}} {{proplist[field].name}}_length() { return _{{proplist[field].name}}_length; }
    {{get_type_string(proplist[field].vector.datatype)}}* {{proplist[field].name}}() { return _{{proplist[field].name}}; }
{% endif %}
{% else %}
    {{get_type_string(proplist[field].type)}} {{proplist[field].name}}() { return _{{proplist[field].name}}; }
{% endif %}

{% endfor %}

private:
    // Device I/O
    Stream& _stream;

    // For decoding PingMessages from the device
    PingParser _parser;

{% for field in proplist %}
    // {{proplist[field].description}}
{% if is_vector(proplist[field].type) %}
{% if proplist[field].vector.sizetype %}
    {{get_type_string(proplist[field].vector.sizetype)}} _{{proplist[field].name}}_length = 0;
{% endif %}
    {{get_type_string(proplist[field].vector.datatype)}}* _{{proplist[field].name}} = 0;
{% else %}
    {{get_type_string(proplist[field].type)}} _{{proplist[field].name}} = 0;
{% endif %}

{% endfor %}

    /**
     *  @brief Read in data from device, return a PingMessage if available.
     *  Data will be read in from device until there is no data left in the RX buffer,
     *  or a valid PingMessage is successfully decoded.
     *  Note that there may still be data available in the RX buffer for decoding when
     *  this function returns a PingMessage.
     *
     *  @return: The next PingMessage from the device
     *  @return: null if the RX buffer is empty and no PingMessage has been decoded
     */
    PingMessage* read();

    /**
     *  @brief Write data to device
     *
     *  @param data: pointer to buffer to write
     *  @param length: buffer length to write
     *
     *  @return: size of data buffer written to the device
     */
    size_t write(uint8_t* data, uint16_t length);

    /**
     *  @brief Wait for receipt of a message with a particular message id from device
     *
     *  @param id: The message id to wait for
     *  @param timeout_ms: The timeout period to wait for a matching PingMessage to be received
     *
     *  @return The PingMessage received with matching id
     *  @return null if the timeout expires and no PingMessage was received with a matching id
     */
    PingMessage* waitMessage(enum Ping1DNamespace::msg_ping1D_id id, uint16_t timeout_ms = 500);

    /**
     *  @brief Handle an incoming message from the device. Internal values are updated according to the device data.
     *
     *  @param pmsg: The message received from the device
     */
    void handleMessage(PingMessage* pmsg);

};
