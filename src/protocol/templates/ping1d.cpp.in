/*
* ping1d.cpp
* A device API for the Blue Robotics Ping1D echosounder
*
*~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
* THIS IS AN AUTOGENERATED FILE
* DO NOT EDIT
*~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
*
*/

#include "ping1d.h"
#include "pingmessage_all.h"

Ping1D::Ping1D(Stream& ser) : _stream ( ser ) {}

Ping1D::~Ping1D()
{
{% for msg in messages["ping1D"]["get"]|sort %}
{% for field in messages["ping1D"]["get"][msg].payload %}
{% if generator.is_vector(field.type) %}
    if (_{{field.name}}) {
       free(_{{field.name}});
    }
{% endif %}
{% endfor %}
{% endfor %}
}

PingMessage* Ping1D::read()
{
    while(_stream.available()) {
        if (_parser.parseByte(_stream.read()) == PingParser::NEW_MESSAGE) {
          return &_parser.rxMsg;
        }
    }
    return nullptr;
}

size_t Ping1D::write(uint8_t* data, uint16_t length)
{
    return _stream.write(data, length);
}

bool Ping1D::initialize(uint16_t ping_interval_ms)
{
    if(!request(Ping1DNamespace::Device_id)) {
        return false;
    }

    if (!request(Ping1DNamespace::Firmware_version)) {
        return false;
    }

    if(!request(Ping1DNamespace::Voltage_5)) {
        return false;
    }

    if (!request(Ping1DNamespace::Processor_temperature)) {
        return false;
    }

    // Configure ping interval
    if (!set_ping_interval(ping_interval_ms)) {
        return false;
    }

    return true;
}

PingMessage* Ping1D::waitMessage(enum Ping1DNamespace::msg_ping1D_id id, uint16_t timeout_ms)
{
    uint32_t tstart = millis();
    while (millis() < tstart + timeout_ms) {

        PingMessage* pmsg = read();

        if (!pmsg) {
            continue;
        }

        handleMessage(pmsg);

        if (pmsg->message_id() == Ping1DNamespace::Nack) {
            ping_msg_ping1D_nack nack(*pmsg);

            if (nack.nacked_id() == id) {
                return nullptr;
            }
        }

        if (pmsg->message_id() == id) {
            return pmsg;
        }
    }

    return nullptr;
}

void Ping1D::handleMessage(PingMessage* pmsg)
{
    switch (pmsg->message_id()) {
{% for msg in messages["ping1D"]["get"]|sort %}
        case Ping1DNamespace::{{msg|title}}:
        {
            ping_msg_ping1D_{{msg}} m(*pmsg);
{% for field in messages["ping1D"]["get"][msg].payload %}
{% if generator.is_vector(field.type) %}
            if (m.{{field.name}}_length() > _{{field.name}}_length) {
                if (_{{field.name}}) {
                    free(_{{field.name}});
                }
                _{{field.name}} = ({{generator.get_type_string(field.vector.datatype)}}*)malloc(_{{field.name}}_length * sizeof({{generator.get_type_string(field.vector.datatype)}}));
            }

            _{{field.name}}_length = m.{{field.name}}_length();

            for (uint16_t i = 0; i < _{{field.name}}_length; i++) {
                _{{field.name}}[i] = m.{{field.name}}()[i];
            }
{% else %}
            _{{field.name}} = m.{{field.name}}();
{% endif %}
{% endfor %}
        }
            break;

{% endfor %}

        default:
            break;
    }
}

// ex ping_msg_ping1D_voltage_5 msg(*pd.request(Ping1DNamespace::Voltage_5));
PingMessage* Ping1D::request(enum Ping1DNamespace::msg_ping1D_id id, uint16_t timeout_ms)
{
    ping_msg_ping1D_empty msg;
    msg.set_id(id);
    msg.updateChecksum();
    write(msg.msgData, msg.msgDataLength());
    return waitMessage(id, timeout_ms);
}

// ex auto msg = pd.request<ping_msg_ping1D_voltage_5>();
template <typename T>
T* Ping1D::request()
{
    T resp; // todo there should be some other (static) way to get the message id?
    static ping_msg_ping1D_empty req;
    req.set_id(resp.message_id());
    req.updateChecksum();
    write(req.msgData, req.msgDataLength());
    return (T*)waitMessage(resp.message_id());
}

{% for msg in messages["ping1D"]["set"]|sort %}
bool Ping1D::{{msg}}({% for field in messages["ping1D"]["set"][msg].payload %}{{generator.get_type_string(field.type)}} {{field.name}}, {% endfor %}bool verify)
{
    ping_msg_ping1D_{{msg}} m;
{% for field in messages["ping1D"]["set"][msg].payload %}
    m.set_{{field.name}}({{field.name}});
{% endfor %}
    m.updateChecksum();
    write(m.msgData, m.msgDataLength());
    if (!request(Ping1DNamespace::{{msg|replace("set_", "")|title}})) {
        return false; // no reply from device
    }
    // Read back the data and check that changes have been applied
    if (verify
{% if messages["ping1D"]["set"][msg].payload %}
        && ({% for field in messages["ping1D"]["set"][msg].payload %}_{{field.name}} != {{field.name}}{{ "\n        || " if not loop.last }}{% endfor %})) {
{% endif %}
        return false; // device reply does not match
    }
    return true; // success
}

{% endfor %}
