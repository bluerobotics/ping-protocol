#pragma once

/// {{class_info.name}} objects provide a wrapper over vector
/// for convenient access and packing of field data
///
/// These files are generated by the ping_generator.py
/// script found in this directory

#ifdef QT_CORE_LIB
#include <QObject>

#endif
{% for message_type in messages %}
namespace {{capitalize(message_type)}}Namespace {
#ifdef QT_CORE_LIB
    Q_NAMESPACE
#endif
    enum msg_{{message_type}}_id {
{% for message in messages[message_type] %}
        {{capitalize(message)}} = {{messages[message_type][message].id}},
{% endfor %}
    };
#ifdef QT_CORE_LIB
    Q_ENUM_NS(msg_{{message_type}}_id)
#endif
};
{% endfor %}

class {{class_info.name}}
{
public:
    {{class_info.name}}() : msgData(nullptr) {}

    {{class_info.name}}(const {{class_info.name}} &msg)
        : _bufferLength(msg.msgDataLength())
    {
        msgData = (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength);
        memcpy(msgData, msg.msgData, _bufferLength);
    }

    {{class_info.name}}(uint16_t bufferLength)
        : _bufferLength(bufferLength)
    {
        msgData = (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength);
    }

    {{class_info.name}}(uint8_t* buf, uint16_t length)
        : _bufferLength(length)
    {
        msgData = (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength);
        memcpy(msgData, buf, _bufferLength);
    }

    {{class_info.name}}& operator = (const {{class_info.name}} &msg) {
        _bufferLength = msg.msgDataLength();
        if(msgData) free(msgData);
        msgData = (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength);
        memcpy(msgData, msg.msgData, _bufferLength);
        return *this;
    }

    ~{{class_info.name}}() { if(msgData) free(msgData); }

protected:
    uint16_t _bufferLength;

public:
    uint8_t* msgData;
    uint16_t bufferLength() const { return _bufferLength; }; // size of internal buffer allocation
    uint16_t msgDataLength() const { return headerLength + payload_length() + checksumLength; }; // size of entire message buffer (header, payload, and checksum)

    uint16_t   payload_length()                const { return *(uint16_t*)(msgData + 2); } // This is ok only because alignment is static
    uint16_t   message_id()                    const { return *(uint16_t*)(msgData + 4); } // This is ok only because alignment is static
    uint8_t    src_device_id()                 const { return *(msgData + 6); }
    uint8_t    dst_device_id()                 const { return *(msgData + 7); }
    uint8_t*   payload_data(int offset=0)      const { return (msgData + 8 + offset); }
    uint16_t   checksum()                      const { return *(uint16_t*)(msgData + msgDataLength() - checksumLength); }

    static const uint8_t headerLength = 8;
    static const uint8_t checksumLength = 2;

    bool verifyChecksum() {
        return checksum() == calculateChecksum();
    }

    void updateChecksum() {
        *(uint16_t*)(msgData + msgDataLength() - checksumLength) = calculateChecksum();
    }

    uint16_t calculateChecksum() {
        uint16_t checksum = 0;
        for(uint32_t i = 0; i < msgDataLength() - checksumLength; i++) {
            checksum += msgData[i];
        }
        return checksum;
    }
};

class ping_msg_ping1D_empty : public PingMessage
{
public:
    ping_msg_ping1D_empty(PingMessage& msg) : PingMessage(msg) {}
    ping_msg_ping1D_empty() {
        _bufferLength = 8 + 2;
        msgData = (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength);
        msgData[0] = 'B';
        msgData[1] = 'R';
        (uint16_t&)msgData[2] = 0; // payload size
        (uint16_t&)msgData[4] = 0; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    void set_id(uint16_t id) { memcpy((msgData + 4 + 0), &id, 2); }
};
