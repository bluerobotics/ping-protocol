#pragma once

/// {{class_info.name}} objects provide a wrapper over vector
/// for convenient access and packing of field data
///
/// These files are generated by the ping_generator.py
/// script found in this directory

#ifdef QT_CORE_LIB
#include <QObject>

#endif
{% for message_type in messages %}
namespace {{capitalize(message_type)}}Namespace {
#ifdef QT_CORE_LIB
    Q_NAMESPACE
#endif
    enum msg_{{message_type}}_id {
{% for message in messages[message_type] %}
        {{capitalize(message)}} = {{messages[message_type][message].id}},
{% endfor %}
    };
#ifdef QT_CORE_LIB
    Q_ENUM_NS(msg_{{message_type}}_id)
#endif
};
{% endfor %}

class {{class_info.name}} // TODO inherit vector?
{
public:
    {{class_info.name}}() {}
    {{class_info.name}}(QByteArray& buf) { msgData = std::vector<uint8_t>(buf.begin(), buf.end()); }
    {{class_info.name}}(std::vector<uint8_t>& buf) { msgData = buf; }
    {{class_info.name}}({{class_info.name}}& msg) { msgData = msg.msgData; }
    ~{{class_info.name}}() {}

    std::vector<uint8_t> msgData;

    uint16_t   payload_length()    { return *(uint16_t*)(msgData.data() + 2); } // This is ok only because alignment is static
    uint16_t   message_id()        { return *(uint16_t*)(msgData.data() + 4); } // This is ok only because alignment is static
    uint8_t    src_device_id()     { return *(msgData.data() + 6); }
    uint8_t    dst_device_id()     { return *(msgData.data() + 7); }
    uint8_t*   payload_data(int offset=0)      { return (msgData.data() + 8 + offset); }
    uint16_t   checksum()          { uint16_t d; memcpy(&d, (msgData.data() + msgData.size() - 2), 2); return d; } // This is required because alignment may be incorrect

    bool verifyChecksum() {
        return checksum() == calculateChecksum();;
    }

    void updateChecksum() {
        uint16_t cs = calculateChecksum();
        memcpy(msgData.data() + msgData.size() - 2, &cs, 2);
    }

    uint16_t calculateChecksum() {
        uint16_t checksum = 0;
        for(uint32_t i = 0; i < msgData.size()-2 /*checksumbytes*/; i++) {
            checksum += msgData.at(i);
        }
        return checksum;
    }
};

class ping_msg_ping1D_empty : public PingMessage
{
public:
    ping_msg_ping1D_empty(QByteArray buf) : PingMessage(buf) {}
    ping_msg_ping1D_empty(PingMessage& msg) : PingMessage(msg) {}
    ping_msg_ping1D_empty() {
        msgData = std::vector<uint8_t>(8 + 2 + 0, 0);
        msgData[0] = 'B';
        msgData[1] = 'R';
        (uint16_t&)msgData[2] = 0; // payload size
        (uint16_t&)msgData[4] = 0; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    void set_id(uint16_t id) { memcpy((msgData.data() + 4 + 0), &id, 2);};

};
