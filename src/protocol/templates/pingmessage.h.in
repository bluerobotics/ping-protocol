#pragma once

/// {{class_info.name}} objects provide a wrapper over vector
/// for convenient access and packing of field data
///
/// These files are generated by the ping_generator.py
/// script found in this directory

#ifdef QT_CORE_LIB
#include <QObject>

#endif
{% for message_type in messages %}
namespace {{capitalize(message_type)}}Namespace {
#ifdef QT_CORE_LIB
    Q_NAMESPACE
#endif
    enum msg_{{message_type}}_id {
{% for message in messages[message_type] %}
        {{capitalize(message)}} = {{messages[message_type][message].id}},
{% endfor %}
    };
#ifdef QT_CORE_LIB
    Q_ENUM_NS(msg_{{message_type}}_id)
#endif
};
{% endfor %}

class {{class_info.name}}
{
public:
    {{class_info.name}}() : msgData { nullptr } {}

    {{class_info.name}}(const {{class_info.name}} &msg)
        : _bufferLength { msg.msgDataLength() }
        , msgData { (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength) }
    {
        memcpy(msgData, msg.msgData, _bufferLength);
    }

    {{class_info.name}}(uint16_t bufferLength)
        : _bufferLength { bufferLength }
        , msgData { (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength) }
    {}

    {{class_info.name}}(uint8_t* buf, uint16_t length)
        : _bufferLength { length }
        , msgData { (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength) }
    {
        memcpy(msgData, buf, _bufferLength);
    }

    {{class_info.name}}& operator = (const {{class_info.name}} &msg) {
        _bufferLength = msg.msgDataLength();
        if(msgData) free(msgData);
        msgData = (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength);
        memcpy(msgData, msg.msgData, _bufferLength);
        return *this;
    }

    ~{{class_info.name}}() { if(msgData) free(msgData); }

protected:
    uint16_t _bufferLength;

public:
    uint8_t* msgData;
    uint16_t bufferLength() const { return _bufferLength; }; // size of internal buffer allocation
    uint16_t msgDataLength() const { return headerLength + payload_length() + checksumLength; }; // size of entire message buffer (header, payload, and checksum)

    uint16_t   payload_length()                const { return *(uint16_t*)(msgData + 2); } // This is ok only because alignment is static
    uint16_t   message_id()                    const { return *(uint16_t*)(msgData + 4); } // This is ok only because alignment is static
    uint8_t    src_device_id()                 const { return *(msgData + 6); }
    uint8_t    dst_device_id()                 const { return *(msgData + 7); }
    uint8_t*   payload_data(int offset=0)      const { return (msgData + 8 + offset); }
    uint16_t   checksum()                      const { return *(uint16_t*)(msgData + msgDataLength() - checksumLength); }

    static const uint8_t headerLength = 8;
    static const uint8_t checksumLength = 2;

    bool verifyChecksum() {
        return checksum() == calculateChecksum();
    }

    void updateChecksum() {
        *(uint16_t*)(msgData + msgDataLength() - checksumLength) = calculateChecksum();
    }

    uint16_t calculateChecksum() {
        uint16_t checksum = 0;

        if(msgDataLength() <= bufferLength()) {
            for(uint32_t i = 0, data_size = msgDataLength() - checksumLength; i < data_size; i++) {
                checksum += static_cast<uint8_t>(msgData[i]);
            }
        }

        return checksum;
    }
};

{% for message_type in messages %}
class {{subclass_info.name}}{{message_type}}_empty : public {{class_info.name}}
{
public:
    {{subclass_info.name}}{{message_type}}_empty({{class_info.name}}& msg) : {{class_info.name}} { msg } {}
    {{subclass_info.name}}{{message_type}}_empty(uint8_t* buf, uint16_t length) : {{class_info.name}} { buf, length } {}
    {{subclass_info.name}}{{message_type}}_empty()
        : {{class_info.name}} { 8 + 2 }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        (uint16_t&)msgData[2] = 0; // payload size
        (uint16_t&)msgData[4] = 0; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    void set_id(uint16_t id) { memcpy((msgData + 4 + 0), &id, 2); }
};
{% endfor %}