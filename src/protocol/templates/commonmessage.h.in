// C++ implementation of the Blue Robotics 'Ping' binary message protocol

//~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
// THIS IS AN AUTOGENERATED FILE
// DO NOT EDIT
//~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

#pragma once

/// {{class_info.name}} objects provide a wrapper over vector
/// for convenient access and packing of field data
///
/// These files are generated by the ping_generator.py
/// script found in this directory

#ifdef QT_CORE_LIB
#include <QObject>
#endif

namespace {{generator.capitalize(class_info.name)}}Namespace {
#ifdef QT_CORE_LIB
    Q_NAMESPACE
#endif
    enum {{class_info.name}}_id {
{% for message in messages['all_msgs'] %}
        {{generator.capitalize(message)}} = {{messages['all_msgs'][message].id}},
{% endfor %}
    };
#ifdef QT_CORE_LIB
    Q_ENUM_NS({{class_info.name}}_id)
#endif
};

class {{class_info.name}}
{
public:
    {{class_info.name}}() : msgData { nullptr } {}

    {{class_info.name}}(const {{class_info.name}} &msg)
        : _bufferLength { msg.msgDataLength() }
        , msgData { (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength) }
    {
        memcpy(msgData, msg.msgData, _bufferLength);
    }

    {{class_info.name}}(const uint16_t bufferLength)
        : _bufferLength { bufferLength }
        , msgData { (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength) }
    {}

    {{class_info.name}}(const uint8_t* buf, const uint16_t length)
        : _bufferLength { length }
        , msgData { (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength) }
    {
        memcpy(msgData, buf, _bufferLength);
    }

    {{class_info.name}}& operator = (const {{class_info.name}} &msg) {
        _bufferLength = msg.msgDataLength();
        if(msgData) free(msgData);
        msgData = (uint8_t*)malloc(sizeof(uint8_t) * _bufferLength);
        memcpy(msgData, msg.msgData, _bufferLength);
        return *this;
    }

    ~{{class_info.name}}() { if(msgData) free(msgData); }

protected:
    uint16_t _bufferLength;

public:
    uint8_t* msgData;
    uint16_t bufferLength() const { return _bufferLength; }; // size of internal buffer allocation
    uint16_t msgDataLength() const { return headerLength + payload_length() + checksumLength; }; // size of entire message buffer (header, payload, and checksum)

    uint16_t payload_length()                const { return *(uint16_t*)(msgData + 2); } // This is ok only because alignment is static
    uint16_t message_id()                    const { return *(uint16_t*)(msgData + 4); } // This is ok only because alignment is static
    uint8_t  src_device_id()                 const { return *(msgData + 6); }
    uint8_t  dst_device_id()                 const { return *(msgData + 7); }
    uint8_t* payload_data(int offset=0)      const { return (msgData + 8 + offset); }
    uint16_t checksum()                      const { return *(uint16_t*)(msgData + msgDataLength() - checksumLength); }

    static const uint8_t headerLength = 8;
    static const uint8_t checksumLength = 2;

    bool verifyChecksum() const {
        if(msgDataLength() > bufferLength()) {
            return false;
        }
        return checksum() == calculateChecksum();
    }

    void updateChecksum() {
        *(uint16_t*)(msgData + msgDataLength() - checksumLength) = calculateChecksum();
    }

    uint16_t calculateChecksum() const {
        uint16_t checksum = 0;

        if(msgDataLength() <= bufferLength()) {
            for(uint32_t i = 0, data_size = msgDataLength() - checksumLength; i < data_size; i++) {
                checksum += static_cast<uint8_t>(msgData[i]);
            }
        }

        return checksum;
    }
};

class {{class_info.name}}{{message_type}}_empty : public {{class_info.name}}
{
public:
    {{class_info.name}}{{message_type}}_empty(const {{class_info.name}}& msg) : {{class_info.name}} { msg } {}
    {{class_info.name}}{{message_type}}_empty(const uint8_t* buf, const uint16_t length) : {{class_info.name}} { buf, length } {}
    {{class_info.name}}{{message_type}}_empty()
        : {{class_info.name}} { 8 + 2 }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        (uint16_t&)msgData[2] = 0; // payload size
        (uint16_t&)msgData[4] = 0; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    void set_id(const uint16_t id) { memcpy((msgData + 4 + 0), &id, 2); }
};

{% for message in messages['all_msgs'] %}
{% set total_payload = generator.calc_payload(messages['all_msgs'][message].payload) %}
class {{class_info.name}}{{message_type}}_{{message}} : public {{class_info.name}}
{
public:
    {{class_info.name}}{{message_type}}_{{message}}(const {{class_info.name}}& msg) : {{class_info.name}} { msg } {}
    {{class_info.name}}{{message_type}}_{{message}}(const uint8_t* buf, const uint16_t length) : {{class_info.name}} { buf, length } {}
    {{class_info.name}}{{message_type}}_{{message}}(
{%- for payload in messages['all_msgs'][message].payload %}
{% if generator.is_vector(payload.type) %}
{% if payload.vector.sizetype -%}
            {{generator.get_type_string(payload.vector.sizetype)}} {{payload.name}}_length
{% else -%}
            uint16_t {{payload.name}}_length
{%- endif %}
{% endif %}
{% endfor %})
        : {{class_info.name}} { static_cast<uint16_t>({{8 + total_payload + 2}}
{%- for payload in messages['all_msgs'][message].payload %}
{% if generator.is_vector(payload.type) %}
 + {{payload.name}}_length
{%- endif %}
{% endfor %}) }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        (uint16_t&)msgData[2] = {{total_payload}}
{%- for payload in messages['all_msgs'][message].payload %}
{% if generator.is_vector(payload.type) %}
 + {{payload.name}}_length
{%- endif %}
{% endfor %}; // payload size
        (uint16_t&)msgData[4] = {{messages['all_msgs'][message].id}}; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

{% set byte = namespace(offset=0, func='') %}
{% if messages['all_msgs'][message].payload %}
{% for payload in messages['all_msgs'][message].payload %}
{% if generator.is_vector(payload.type) %}
{% if payload.vector.sizetype %}
    {{generator.get_type_string(payload.vector.sizetype)}} {{payload.name}}_length() const { {{generator.get_type_string(payload.vector.sizetype, name='d')}}; memcpy(&d, (payload_data({{byte.offset}})), {{generator.get_c_size(payload.vector.sizetype)}}); return d; };
    //TODO do this in constructor (const)
    void set_{{payload.name}}_length(const {{generator.get_type_string(payload.vector.sizetype)}} {{payload.name}}_length) { memcpy((payload_data({{byte.offset}})), &{{payload.name}}_length, {{generator.get_c_size(payload.vector.sizetype)}});};
{% set byte.offset = byte.offset + generator.get_c_size(payload.vector.sizetype) %}
{% endif %}
    {{generator.get_type_string(payload.vector.datatype)}}* {{payload.name}}() const { return ({{generator.get_type_string(payload.vector.datatype)}}*)(payload_data({{byte.offset}})); }
    void set_{{payload.name}}_at(const uint16_t i, const {{generator.get_type_string(payload.vector.datatype)}} data) { memcpy((payload_data({{byte.offset}} + i)), &data, 1); }
{% else %}
    {{generator.get_type_string(payload.type)}} {{payload.name}}() const { {{generator.get_type_string(payload.type, name='d')}}; memcpy(&d, (payload_data({{byte.offset}})), {{generator.get_c_size(payload.type)}}); return d; };
    void set_{{payload.name}}(const {{generator.get_type_string(payload.type)}} {{payload.name}}) { memcpy((payload_data({{byte.offset}})), &{{payload.name}}, {{generator.get_c_size(payload.type)}});};
{% set byte.offset = byte.offset + generator.get_c_size(payload.type) %}
{% endif %}
{% endfor %}
{% endif %}
};

{% endfor %}
