// C++ implementation of the Blue Robotics 'Ping' binary message protocol

//~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
// THIS IS AN AUTOGENERATED FILE
// DO NOT EDIT
//~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

#pragma once

#include "pingmessage.h"

{% set message_type = _actual_message_type %}
{% for message in messages[message_type]['all_msgs'] %}
{% set total_payload = calc_payload(messages[message_type]['all_msgs'][message].payload) %}
class {{subclass_info.name}}{{message_type}}_{{message}} : public {{class_info.name}}
{
public:
    {{subclass_info.name}}{{message_type}}_{{message}}(const PingMessage& msg) : {{class_info.name}} { msg } {}
    {{subclass_info.name}}{{message_type}}_{{message}}(const uint8_t* buf, const uint16_t length) : {{class_info.name}} { buf, length } {}
    {{subclass_info.name}}{{message_type}}_{{message}}(
{%- for payload in messages[message_type]['all_msgs'][message].payload %}
{% if is_vector(payload.type) %}
{% if payload.vector.sizetype -%}
            {{get_type_string(payload.vector.sizetype)}} {{payload.name}}_length
{% else -%}
            uint16_t {{payload.name}}_length
{%- endif %}
{% endif %}
{% endfor %})
        : {{class_info.name}} { static_cast<uint16_t>({{8 + total_payload + 2}}
{%- for payload in messages[message_type]['all_msgs'][message].payload %}
{% if is_vector(payload.type) %}
 + {{payload.name}}_length
{%- endif %}
{% endfor %}) }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        (uint16_t&)msgData[2] = {{total_payload}}
{%- for payload in messages[message_type]['all_msgs'][message].payload %}
{% if is_vector(payload.type) %}
 + {{payload.name}}_length
{%- endif %}
{% endfor %}; // payload size
        (uint16_t&)msgData[4] = {{messages[message_type]['all_msgs'][message].id}}; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

{% set byte = namespace(offset=0, func='') %}
{% if messages[message_type]['all_msgs'][message].payload %}
{% for payload in messages[message_type]['all_msgs'][message].payload %}
{% if is_vector(payload.type) %}
{% if payload.vector.sizetype %}
    {{get_type_string(payload.vector.sizetype)}} {{payload.name}}_length() const { {{get_type_string(payload.vector.sizetype, name='d')}}; memcpy(&d, (payload_data({{byte.offset}})), {{get_c_size(payload.vector.sizetype)}}); return d; };
    //TODO do this in constructor (const)
    void set_{{payload.name}}_length(const {{get_type_string(payload.vector.sizetype)}} {{payload.name}}_length) { memcpy((payload_data({{byte.offset}})), &{{payload.name}}_length, {{get_c_size(payload.vector.sizetype)}});};
{% set byte.offset = byte.offset + get_c_size(payload.vector.sizetype) %}
{% endif %}
    {{get_type_string(payload.vector.datatype)}}* {{payload.name}}() const { return ({{get_type_string(payload.vector.datatype)}}*)(payload_data({{byte.offset}})); }
    void set_{{payload.name}}_at(const uint16_t i, const {{get_type_string(payload.vector.datatype)}} data) { memcpy((payload_data({{byte.offset}} + i)), &data, 1); }
{% else %}
    {{get_type_string(payload.type)}} {{payload.name}}() const { {{get_type_string(payload.type, name='d')}}; memcpy(&d, (payload_data({{byte.offset}})), {{get_c_size(payload.type)}}); return d; };
    void set_{{payload.name}}(const {{get_type_string(payload.type)}} {{payload.name}}) { memcpy((payload_data({{byte.offset}})), &{{payload.name}}, {{get_c_size(payload.type)}});};
{% set byte.offset = byte.offset + get_c_size(payload.type) %}
{% endif %}
{% endfor %}
{% endif %}
};

{% endfor %}
