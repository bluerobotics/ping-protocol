#!/usr/bin/env python3

"""Json generator for decoding test
This script will generate a json file that contains protocol messages
and the data defined in the payload data with fake values.
This fake values are used to see if the c++ code can decode
in the way that is described in the protocol description file.
"""

import argparse
import json
import os
import struct

# PingMessage is generated by this project
import sys
sys.path.append("../src/protocol/python")
import PingMessage as Message


def generate_fake_data(message_format: str) -> bytearray:
    """Generates fake data to decode

    Arguments:
        message_format {str} -- String that represents the struct format

    Returns:
        bytearray -- A random array of bytes with the size of format
    """

    return bytearray(os.urandom(struct.calcsize(message_format)))


def generate_payload_dict(message_format: str, payload_data: str, payload_fields: str) -> dict:
    """Create a dict of payload values

    Arguments:
        message_format {str} -- String that represents the struct format
        payload_data {str} -- Payload content
        payload_fields {str} -- Payload variables

    Returns:
        dict -- A dict that contains each payload variable with the decoded value,
        this values does not need to make sense.
        {'device_type': 129, 'device_model': 58, ...}
    """

    values = list(struct.unpack(message_format, payload_data))
    data = {}
    for value, key in zip(values, payload_fields):
        data[key] = value
    return data


#Checksum = sum(0 -> n) & 0xffff
def calculate_protocol_checksum(header_data: str, payload_data: str) -> int:
    """Calculate checksum from header and payload

    Arguments:
        header_data {str} -- Header data
        payload_data {str} -- Payload data

    Returns:
        int -- Checksum value
    """

    header_unpacked = struct.unpack("<BBBBBBBB", header_data)
    if payload_data is None:
        payload_data = ()
    payload_format = '<' + (len(payload_data) * 'B')
    try:
        payload_unpacked = struct.unpack(payload_format, payload_data)
    except Exception as error:
        print("It was not possible to unpack data.\nError: {}" % error)
        payload_unpacked = ()

    sum_of_bytes = sum(header_unpacked) + sum(payload_unpacked)
    checksum = sum_of_bytes & 0xffff

    return checksum

def pack_protocol_message(message_id: int,
                          message: dict,
                          payload: str,
                          destination_device_id: int
                          ) -> str:
    """Pack protocol message

    Arguments:
        message_id {int} -- Message id
        message {dict} -- Message description dictionary
        payload {str} -- Payload content
        destination_device_id {int} -- Id of the device that will receive the message

    Returns:
        str -- bytecode message
    """

    #Needed to build header
    payload_size = struct.calcsize(message['format'])

    #Create and pack header
    header = [b'B', b'R', payload_size, message_id, 0, destination_device_id]
    final_header = struct.pack('<ccHHBB', *header)

    #Create Checksum
    checksum = calculate_protocol_checksum(final_header, payload)
    final_checksum = struct.pack('<H', checksum)
    return b''.join([final_header, payload, final_checksum])


def main():
    """Main function
    Run the main script
    """

    # argparse for future devices
    parser = argparse.ArgumentParser(
        description="Script to generate json test description file for ping protocol!")
    parser.add_argument(
        '--device',
        action="store",
        type=str,
        default="Ping1D",
        help="Ping device type.")
    args = parser.parse_args()

    # Create json file with everything that we need
    json_content = {
        'device': args.device,
        'messages': []
    }
    for message_id, ping_message in Message.payloadDict.items():
        data = {
            'name': ping_message['name'],
            'id': message_id,
            'data': None,
            'bytes': None
        }
        var_payload = {}
        key = ''
        # Generate random text or array of bytes
        if message_id in [Message.PING1D_ASCII_TEXT, Message.PING1D_NACK]:
            if message_id == Message.PING1D_ASCII_TEXT:
                key = 'msg'
            elif message_id == Message.PING1D_NACK:
                key = 'nack_msg'
            var_payload[key] = b' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\0'
        elif message_id == Message.PING1D_PROFILE:
            var_payload['data'] = [x for x in range(200)]

        # Create data with all bytes of the message
        payload = generate_fake_data(ping_message['format'])
        if var_payload:
            size = 0
            for key, value in var_payload.items():
                payload += struct.pack(str(len(value)) + 'B', *value)
                size += len(value)
            ping_message['format'] = ping_message['format'] + str(size) + 'B'

        data['data'] = generate_payload_dict(ping_message['format'],
                                             payload, ping_message['field_names'])
        if key:
            if isinstance(var_payload[key], bytes):
                data['data'][key] = var_payload[key].decode("ascii")
            else:
                data['data'][key] = var_payload[key]

        data['bytes'] = list(pack_protocol_message(message_id, ping_message, payload, 1))
        json_content['messages'].append(data)

    with open('ping1D_v3.17.json', 'w') as output_file:
        json.dump(json_content, output_file, indent=2)
        output_file.close()

if __name__ == "__main__":
    main()
